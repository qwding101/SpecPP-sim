getwd()
library(dplyr)
library(stringr)
library(spatstat)
library(viridis)
library(ggplot2)
library(cowplot)
source("../../func/func_bci.R", chdir = T)
### Import BCI data
load("../../data/bci/140709MR_bci7.Rda")
load("../../data/bci/140709MR_bci.covars.Rda")
# Below code is copied from Jalilian et al. (2015)'s supplementary material to
# select the five tree species
ab = which((table(bci7$marks) > 3000) & (table(bci7$marks) < 5000))
markset = names(ab)[-(5:6)]
ind = bci7$marks %in% markset
X = bci7[ind]
X$marks = as.factor(as.character(bci7$marks[ind]))
### Define some functions for visualization
# Plot the kernel spectral density estimate (KSDE)
plot.spec.fun = function(mat.in.list, freq.list, ylim = NULL){
omega.comb = as.data.frame(freq.list$omega.comb)
omega.comb$Density = as.vector(t(mat.in.list))
omega.comb$dist = sqrt(omega.comb$omega1^2 + omega.comb$omega2^2)
df.plot = group_by(omega.comb, dist) %>%
summarise(avg.density = mean(Density), num.avg = n())
plot(df.plot$dist, df.plot$avg.density,
xlab = "", ylab = "", main = "", ylim = ylim,
type = "l", bty = "l",
col = "black", lwd = 0.5,
las = 1,
xaxt = 'n',
tck = -0.025, mgp = c(3, .3, 0), cex.axis = 1)
axis(1, at = c(0,2,4,6), tck = -0.025, mgp = c(3, 0.2, 0), cex.axis = 1)
}
# Plot the pair correlation function
plot.PCF.fun = function(ppp, i, j, lambda){
pcf.ij = pcfcross.inhom(ppp, i, j, lambda[[i]], lambda[[j]], correction = "Ripley")
plot.fv(pcf.ij, iso - 1 ~ r,
xlab = "", ylab = "", main = "",
bty = "l", las = 1,
col = "black", lwd = 0.5,
xaxt = 'n',
tck = -0.025, mgp = c(3, .3, 0), cex.axis = 1)
abline(h = 0, col = "gray", lty = "dotted", lwd = 2)
axis(1, at = c(0,2,4), tck = -0.025, mgp = c(3, 0.2, 0), cex.axis = 1)
}
### Other specifications for spectral analysis
a = 0.025 # Data taper
# Rescale the observational domain of the BCI data
scale.factor = 20
unitname(X) = c("metre", "metres")
for (i in 1:length(bci.covars)){
unitname(bci.covars[[i]]) = c("metre", "metres")
}
X = rescale(X, scale.factor)
for (i in 1:length(bci.covars)){
bci.covars[[i]] = rescale(bci.covars[[i]], scale.factor)
}
### Fit the log-linear model of the intensity functions
Xs = split.ppp(X)
inten.li = vector("list", length(Xs)); names(inten.li) = names(Xs)
m.covariate = " ~ x + y + x:y + Cu + dem + grad + K + mrvbf + Nmin + P + pH + solar + twi"
cate = levels(marks(X))
cate.comb = cate.comb.fun(cate)
for (i in 1:length(Xs)){
inten.li[[i]] = predict.ppm(ppm(as.formula(paste0("Xs$", names(Xs)[i], m.covariate)),
data = bci.covars))
}
### Select the bandwidth by cross-validation:
band.range = seq(0.5, 0.8, .01)
cv = bandwidth.cv.fun(ppp = X, inten.formula = m.covariate,
data.covariate = bci.covars, band.range=band.range,
endpt = 1.5, equal = T, a = a)
plot(cv$Result[1,], cv$Result[2,],
xlab = "Bandwidth", ylab = expression(italic(L)(italic(b))),
type = "l", bty = "l", las = 1, lwd = 2, col = "gray30")
abline(v = cv$`Optimal bandwidth`, col = "#0047ab", lwd = 2, lty = "dashed")
cv$`Optimal bandwidth`
getwd()
### Given the bandwidth above, compute the KSDE
period.smooth.mat = period.2Dsmooth.fun(ppp = X,
inten.formula = m.covariate,
data.covariate = bci.covars,
bandwidth = cv$`Optimal bandwidth`,
endpt = 1.5, equal = T, a = a)
saveRDS(period.smooth.mat, "bci_ksde.rds")
period.smooth.list.Re = lapply(period.smooth.mat, Re) # Extract the real part of the KSDE
mostattributes(period.smooth.list.Re) = attributes(period.smooth.mat)
### Based on the KSDE, compute the coherence estimate
coh.li = vector("list", length(period.smooth.list.Re))
names(coh.li) = names(period.smooth.list.Re)
for (k in seq_along(period.smooth.list.Re)){
if (cate.comb[k, 1] != cate.comb[k, 2]){
coh.li[[k]] = period.smooth.list.Re[[k]]/sqrt(period.smooth.list.Re[[paste0(rep(cate.comb[k, 1],2), collapse=", ")]]*period.smooth.list.Re[[paste0(rep(cate.comb[k, 2],2), collapse=", ")]])
}else{
coh.li[[k]] = period.smooth.list.Re[[k]]
}
}
### Specify the layout of the plot
idx.1 = seq_along(cate)
idx.2 = (length(cate)+1):(length(cate)+1*sum(seq_along(cate)))
idx.3 = (idx.2[length(idx.2)]+1):(length(cate)+2*sum(seq_along(cate)))
mat.layout = matrix(0, nrow = length(cate), ncol = 1 + 1 + length(cate) + 2)
mat.layout[, 1] = idx.1
mat.layout.right1 = mat.layout[, 3:(3+length(cate)-1)]
mat.layout.right1[lower.tri(mat.layout.right1, diag = T)] = idx.2
mat.layout[, 3:(3+length(cate)-1)] = mat.layout.right1
mat.layout.right2 = mat.layout[, 5:ncol(mat.layout)]
up.tri.idx = which(upper.tri(mat.layout.right2, diag = T), arr.ind = T)
mat.layout.right2[up.tri.idx[order(up.tri.idx[,1]), ]] = idx.3
mat.layout[, 5:ncol(mat.layout)] = mat.layout.right2
### Plot figure 2
cairo_pdf("figure 2.pdf", width = 8.25, height = 5, bg = "transparent")
layout(mat.layout, widths = c(1.75, 0.05, rep(1, length(cate) + 2)))
title.idx.l = (length(cate)+1):(2*length(cate))
title.idx.b = cumsum(c(2*length(cate), (length(cate)-1):1))
title.idx.t = (max(title.idx.b)+1):(max(title.idx.b)+length(cate))
title.idx.r = cumsum(c(max(title.idx.t), (length(cate)-1):1))
names(title.idx.l) = names(title.idx.b) = names(title.idx.t) = names(title.idx.r) = cate
r = 1
for (i in seq_along(Xs)){
# par(mar = c(1.5,0,1.5,0), font.main = 1, cex = 0.5)
par(mar = c(1.6,0,1.6,0), font.main = 1, cex = 0.5)
plot.ppp(Xs[[i]], pch = 16, cex = .1, main = "")
# title(bquote(italic(X)[.(i)]*","* ~ .(str_to_sentence(names(Xs)[i])) ~ (italic('n') ~ "=" ~ .(Xs[[i]]$n))),
#       line = 0.7)
title(bquote(italic(X)[.(i)] ~ (italic('n') ~ "=" ~ .(Xs[[i]]$n))),
line = 0.7)
r = r + 1
}
for (k in seq_along(coh.li)){
# par(mar = c(2.4,1.75,2,1.75))
par(mar = c(1.8,1.75,1.9,1.3))
if (cate.comb[k,1] == cate.comb[k,2]){
plot.spec.fun(coh.li[[k]], attr(period.smooth.list.Re, "freq.list"))
}else{
plot.spec.fun(coh.li[[k]], attr(period.smooth.list.Re, "freq.list"), ylim = c(-0.4,0.5))
}
if (r %in% title.idx.l){
mtext(text = bquote(italic(X)[.(which(title.idx.l %in% r))]),
side = 2, cex = 0.6, line = 2.2)
}
if (r %in% title.idx.b){
mtext(text = bquote(italic(X)[.(which(title.idx.b %in% r))]),
side = 1, cex = 0.6, line = 1)
}
if (cate.comb[k,1] == cate.comb[k,2]){
abline(h = (2*pi)^(-2)*H.mat$H_h2l.val[cate.comb[k,1], cate.comb[k,2]]/H.mat$H_h2,
col = "gray", lty = "dotted", lwd = 2)
}else{
abline(h = 0, col = "gray", lty = "dotted", lwd = 2)
}
r = r + 1
}
H.mat = Hmatrix(period.smooth.mat, X) # This will be used to plot the asymptote line of the marginal KSDE later
dev.off()
### Plot figure 2
cairo_pdf("figure 2.pdf", width = 8.25, height = 5, bg = "transparent")
layout(mat.layout, widths = c(1.75, 0.05, rep(1, length(cate) + 2)))
title.idx.l = (length(cate)+1):(2*length(cate))
title.idx.b = cumsum(c(2*length(cate), (length(cate)-1):1))
title.idx.t = (max(title.idx.b)+1):(max(title.idx.b)+length(cate))
title.idx.r = cumsum(c(max(title.idx.t), (length(cate)-1):1))
names(title.idx.l) = names(title.idx.b) = names(title.idx.t) = names(title.idx.r) = cate
r = 1
for (i in seq_along(Xs)){
# par(mar = c(1.5,0,1.5,0), font.main = 1, cex = 0.5)
par(mar = c(1.6,0,1.6,0), font.main = 1, cex = 0.5)
plot.ppp(Xs[[i]], pch = 16, cex = .1, main = "")
# title(bquote(italic(X)[.(i)]*","* ~ .(str_to_sentence(names(Xs)[i])) ~ (italic('n') ~ "=" ~ .(Xs[[i]]$n))),
#       line = 0.7)
title(bquote(italic(X)[.(i)] ~ (italic('n') ~ "=" ~ .(Xs[[i]]$n))),
line = 0.7)
r = r + 1
}
for (k in seq_along(coh.li)){
# par(mar = c(2.4,1.75,2,1.75))
par(mar = c(1.8,1.75,1.9,1.3))
if (cate.comb[k,1] == cate.comb[k,2]){
plot.spec.fun(coh.li[[k]], attr(period.smooth.list.Re, "freq.list"))
}else{
plot.spec.fun(coh.li[[k]], attr(period.smooth.list.Re, "freq.list"), ylim = c(-0.4,0.5))
}
if (r %in% title.idx.l){
mtext(text = bquote(italic(X)[.(which(title.idx.l %in% r))]),
side = 2, cex = 0.6, line = 2.2)
}
if (r %in% title.idx.b){
mtext(text = bquote(italic(X)[.(which(title.idx.b %in% r))]),
side = 1, cex = 0.6, line = 1)
}
if (cate.comb[k,1] == cate.comb[k,2]){
abline(h = (2*pi)^(-2)*H.mat$H_h2l.val[cate.comb[k,1], cate.comb[k,2]]/H.mat$H_h2,
col = "gray", lty = "dotted", lwd = 2)
}else{
abline(h = 0, col = "gray", lty = "dotted", lwd = 2)
}
r = r + 1
}
for (k in seq_along(period.smooth.list.Re)){
# par(mar = c(2.4,1.75,2,1.75))
par(mar = c(1.8,1.75,1.9,1.3))
plot.PCF.fun(ppp = X, i = cate.comb[k,1], j = cate.comb[k,2], lambda = inten.li)
if (r %in% title.idx.t){
mtext(text = bquote(italic(X)[.(which(title.idx.t %in% r))]),
side = 3, cex = 0.6)
}
if (r %in% title.idx.r){
mtext(text = bquote(italic(X)[.(which(title.idx.r %in% r))]),
side = 4, cex = 0.6)
#   text(x = par("usr")[2], y = mean(par("usr")[3:4]),
#        labels = bquote(italic(X)[.(which(title.idx.r %in% r))]*","* ~ .(str_to_sentence(cate[which(title.idx.r %in% r)]))),
#        srt = -90, cex = 1.3)
}
r = r + 1
}
dev.off()
